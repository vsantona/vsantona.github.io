<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Event Sourcing with Axon Framework | Vincenzo Santonastaso</title><meta name=keywords content><meta name=description content="A pragmatic journey through Event Sourcing with Axon Framework, including real-world use cases, trade-offs, and when it makes sense."><meta name=author content="Vincenzo Santonastaso"><link rel=canonical href=https://vsantona.github.io/posts/event-sourcing-with-axon-framework/><link crossorigin=anonymous href=../../assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://vsantona.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://vsantona.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://vsantona.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://vsantona.github.io/apple-touch-icon.png><link rel=mask-icon href=https://vsantona.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://vsantona.github.io/posts/event-sourcing-with-axon-framework/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://vsantona.github.io/posts/event-sourcing-with-axon-framework/"><meta property="og:site_name" content="Vincenzo Santonastaso"><meta property="og:title" content="Event Sourcing with Axon Framework"><meta property="og:description" content="A pragmatic journey through Event Sourcing with Axon Framework, including real-world use cases, trade-offs, and when it makes sense."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-16T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-16T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Event Sourcing with Axon Framework"><meta name=twitter:description content="A pragmatic journey through Event Sourcing with Axon Framework, including real-world use cases, trade-offs, and when it makes sense."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://vsantona.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Event Sourcing with Axon Framework","item":"https://vsantona.github.io/posts/event-sourcing-with-axon-framework/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Event Sourcing with Axon Framework","name":"Event Sourcing with Axon Framework","description":"A pragmatic journey through Event Sourcing with Axon Framework, including real-world use cases, trade-offs, and when it makes sense.","keywords":[],"articleBody":"Event Sourcing with Axon Framework (and when it actually makes sense) I’ve been playing with Event Sourcing for a while now, and I’ll be honest: the first time I read about it, I thought everything was overcomplicated. “Just save the state, why do you need to store every single thing that happened?” But before understanding what it is, I think it’s fundamental to understand what problems it tries to solve.\nWhat is Event Sourcing (really)? Think about your bank account. When you open your banking app, you see a balance. That’s state. But how did you get there? You had deposits, withdrawals, transfers, fees. Those are events.\nMost systems only store the current balance. Done. Event Sourcing flips that: it stores every event that ever happened, and derives the current state by replaying them. Your balance isn’t stored directly; it’s calculated from every transaction since you opened the account.\nWhy would anyone do this? Because in some domains, the events are the truth. The history matters. Auditing, compliance, debugging production issues, understanding user behavior, all of that becomes trivial when you have the full event log.\nOf course, this sounds insane to most developers at first. “You’re telling me I have to replay thousands of events just to know if a user has enough credit?” More or less. There are snapshots and optimizations for that.\nWhen should you use Event Sourcing? Let’s be real: most CRUD apps don’t need this. If you’re building a basic task manager or a blog platform, just use Spring Data JPA.\nEvent Sourcing makes sense when audit trails are critical. Let’s think about financial systems, healthcare, legal stuff. Or when the process matters as much as the outcome, like order fulfillment or approval workflows. When you need to replay or reprocess past decisions for analytics or ML training data. When business rules change and you need to reinterpret tax calculations, pricing models, and things like that.\nWhen does it make less sense? Simple CRUD where the current state is all that matters. High throughput write scenarios with no historical value. Teams not ready for the mental overhead of eventual consistency. Tight deadlines with no time to learn the model.\nTrade-offs? You’re dealing with more complex queries, more moving parts, more storage. Every event is persisted forever. There’s a learning curve you have to deal with.\nAxon Framework in 2 minutes Axon is a Java framework that makes Event Sourcing and CQRS (Command Query Responsibility Segregation) less painful. Without it, you have to build your own event store, handle command routing, manage projections, and deal with eventual consistency. It’s a lot of stuff.\nAxon gives you an event store out of the box, aggregates that manage their own consistency, automatic command and query handling, sagas for long-running business processes, and snapshot support so you don’t replay all events every time.\nIt doesn’t make Event Sourcing easy, but it makes it survivable. You still have to think differently about your domain model. You still have to deal with eventual consistency. But at least the plumbing is handled.\nLet’s see a real use case: Product lifecycle Let’s say you’re building a system that manages product orders. A product goes through multiple stages: reserved, confirmed, delivered. Different teams interact with it. Support needs to know why a product got stuck. Finance needs to audit when things were confirmed and payment results.\nWith traditional JPA entities, you’d probably have something like:\n@Entity class Product( @Id val id: String, var status: ProductStatus, var customerId: String?, var amount: BigDecimal?, var reservedAt: Instant?, var confirmedAt: Instant?, var deliveredAt: Instant?, var canceledAt: Instant?, var cancelReason: String? ) This works until it doesn’t. You start adding more fields: canceledAt, canceledReason, confirmedBy, reservationExpiredAt. Your entity becomes a bit heavy. Queries get messy. And when someone asks “why did this product get delivered without confirmation?” you have no idea because you only stored the final state.\nSolving the problem with Event Sourcing Quick terminology crash course, because you’ll see these everywhere:\nAggregate - The single source of truth for a specific entity. It enforces business rules and decides whether a command is valid. Think of it as a goalkeeper that protects consistency.\nCommand - An instruction to do something (“ReserveProduct”, “ConfirmOrder”). It can be rejected if it violates business rules.\nEvent - A fact that already happened (“ProductReserved”, “OrderConfirmed”). Events can’t be rejected because they’re in the past.\nProjection - A read model built by listening to events. It’s optimized for queries, not for business logic. You can have multiple projections for different purposes.\nSaga - A long-running process that coordinates multiple aggregates and represents a workflow. It listens to events and sends commands to orchestrate complex workflows (like “when product is reserved, charge the credit card, then confirm the order”).\nWith Axon, you model the lifecycle as a series of events. The aggregate replays them to reconstruct its state.\n@Aggregate class ProductAggregate() { @AggregateIdentifier private lateinit var productId: String private var state: ProductState? = null private lateinit var customerId: String private lateinit var amount: BigDecimal @CommandHandler constructor(command: ReserveProductCommand) : this() { if (state != null) { throw IllegalStateException(\"Product cannot be reserved twice.\") } apply(ProductReservedEvent(command.productId, command.customerId, command.amount)) } @EventSourcingHandler fun on(event: ProductReservedEvent) { productId = event.productId customerId = event.customerId amount = event.amount state = ProductState.RESERVED } @CommandHandler fun handle(command: ConfirmProductCommand) { if (state != ProductState.RESERVED) { throw IllegalStateException(\"Only a RESERVED product can be confirmed.\") } apply(ProductConfirmedEvent(productId)) } @EventSourcingHandler fun on(event: ProductConfirmedEvent) { state = ProductState.CONFIRMED } enum class ProductState { RESERVED, CONFIRMED, DELIVERED, CANCELED } } See what’s happening? Commands express intent. Events express facts. The aggregate enforces rules.\nWhen you load a ProductAggregate from the event store, Axon replays events rebuilding the state. You get full traceability for free (or at least that’s the perception).\nFor queries, you build projections:\n@Component class ProductProjection(private val jdbcTemplate: JdbcTemplate) { @EventHandler fun on(event: ProductReservedEvent) { jdbcTemplate.update( \"INSERT INTO product_view (product_id, status, customer_id, amount, reserved_at) VALUES (?, ?, ?, ?, ?)\", event.productId, \"RESERVED\", event.customerId, event.amount, Instant.now() ) } @EventHandler fun on(event: ProductConfirmedEvent) { jdbcTemplate.update( \"UPDATE product_view SET status = ?, confirmed_at = ? WHERE product_id = ?\", \"CONFIRMED\", Instant.now(), event.productId ) } @QueryHandler fun handle(query: GetProductQuery): ProductView? { return jdbcTemplate.queryForObject( \"SELECT * FROM product_view WHERE product_id = ?\", { rs, _ -\u003e ProductView( productId = rs.getString(\"product_id\"), status = rs.getString(\"status\"), customerId = rs.getString(\"customer_id\"), amount = rs.getBigDecimal(\"amount\"), reservedAt = rs.getTimestamp(\"reserved_at\")?.toInstant(), confirmedAt = rs.getTimestamp(\"confirmed_at\")?.toInstant() ) }, query.productId ) } } The projection listens to events and builds a read model optimized for queries. You can have multiple projections for different use cases. One for the API. One for reporting. One for machine learning. The read model can be persisted on a table, a NoSQL database, exported to a data warehouse, whatever fits your needs.\nNow, what about sagas? Let’s say your product reservation needs to trigger a payment, and only after payment succeeds should the product be confirmed. That’s cross aggregate coordination. A saga listens to ProductReservedEvent, sends a ChargePaymentCommand, waits for PaymentSucceededEvent, then sends ConfirmProductCommand. If payment fails, it sends CancelReservationCommand. You’re orchestrating a multi-step process without coupling your aggregates together. It’s messy in traditional architectures-sagas make it explicit and testable.\nHere’s what the saga looks like:\n@Saga class ProductLifecycleSaga { private lateinit var productId: String private lateinit var paymentId: String @StartSaga @SagaEventHandler(associationProperty = \"productId\") fun on(event: ProductReservedEvent, commandGateway: CommandGateway) { productId = event.productId paymentId = UUID.randomUUID().toString() commandGateway.send(ChargePaymentCommand( paymentId = paymentId, productId = event.productId, customerId = event.customerId, amount = event.amount )) } @SagaEventHandler(associationProperty = \"productId\") fun on(event: PaymentSucceededEvent, commandGateway: CommandGateway) { commandGateway.send(ConfirmProductCommand(event.productId)) } @SagaEventHandler(associationProperty = \"productId\") fun on(event: PaymentFailedEvent, commandGateway: CommandGateway) { commandGateway.send(CancelReservationCommand( productId = event.productId, reason = \"Payment failed: ${event.reason}\" )) } @SagaEventHandler(associationProperty = \"productId\") fun on(event: ProductConfirmedEvent, commandGateway: CommandGateway) { commandGateway.send(DeliverProductCommand(productId)) } @EndSaga @SagaEventHandler(associationProperty = \"productId\") fun on(event: ProductDeliveredEvent) { } @EndSaga @SagaEventHandler(associationProperty = \"productId\") fun on(event: ProductReservationCanceledEvent) { } } The saga starts when a product is reserved, sends a payment charge command, waits for payment success or failure, then either confirms the product (on success) or cancels the reservation (on failure). After confirmation, it triggers delivery. Each step is explicit. Each transition is traceable. If something fails, you know exactly where and why.\nAnd here’s the upside: if business rules change, you can rebuild projections from scratch by replaying all events. Try doing that with a relational database where you’ve been mutating rows for three years.\nEvent Sourcing isn’t a magic bullet. It won’t make your codebase simpler. It won’t make your queries faster. But it will make certain problems like auditing, compliance and complex workflows much more manageable.\nAxon Framework handles the boring infrastructure stuff so you can focus on modeling your domain properly. It’s opinionated, which is good when you’re trying to learn a new paradigm.\nIs it overkill for most projects? Absolutely. Should you use it everywhere? Absolutely no. But when you’re staring at a tangled mess of status fields and audit data, and someone asks “how did we get here?” that’s when Event Sourcing starts to make sense.\nI’m still learning this stuff, honestly. Some days I love it. Some days I miss the simplicity of UPDATE products SET status = 'CONFIRMED'. But for the right problems, it’s an efficient way to model the domain.\nOne thing I haven’t covered here: the whole “separate your reads from your writes” thing. That’s CQRS, and it deserves its own conversation. Spoiler: it works really well with Event Sourcing, but you don’t need one to use the other.\nWant to go deeper? If you’re curious and want to learn more about this stuff, here are some resources that actually helped me:\nAxon Framework Documentation\nhttps://docs.axoniq.io/\nThe official docs (surprisingly readable).\nBuilding Event-Driven Microservices\nby Adam Bellemare (O’Reilly Media)\nThis book isn’t specifically about Axon, but it’s one of the better explanations of event-driven architecture I’ve read. It covers event sourcing, stream processing, and how to actually structure these systems in production. Less theory, more “here’s how you actually build this.”\nDomain-Driven Design\nby Eric Evans (Addison-Wesley)\nThe blue book. If you’re going to do Event Sourcing seriously, you need to understand DDD.\n","wordCount":"1675","inLanguage":"en","datePublished":"2026-01-16T00:00:00Z","dateModified":"2026-01-16T00:00:00Z","author":{"@type":"Person","name":"Vincenzo Santonastaso"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vsantona.github.io/posts/event-sourcing-with-axon-framework/"},"publisher":{"@type":"Organization","name":"Vincenzo Santonastaso","logo":{"@type":"ImageObject","url":"https://vsantona.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://vsantona.github.io/ accesskey=h title="Vincenzo Santonastaso (Alt + H)">Vincenzo Santonastaso</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://vsantona.github.io/resume/ title=Resume><span>Resume</span></a></li><li><a href=https://vsantona.github.io/about/ title=About><span>About</span></a></li><li><a href=https://vsantona.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Event Sourcing with Axon Framework</h1><div class=post-meta><span title='2026-01-16 00:00:00 +0000 UTC'>January 16, 2026</span>&nbsp;·&nbsp;<span>Vincenzo Santonastaso</span></div></header><div class=post-content><h1 id=event-sourcing-with-axon-framework-and-when-it-actually-makes-sense>Event Sourcing with Axon Framework (and when it actually makes sense)<a hidden class=anchor aria-hidden=true href=#event-sourcing-with-axon-framework-and-when-it-actually-makes-sense>#</a></h1><p>I&rsquo;ve been playing with Event Sourcing for a while now, and I&rsquo;ll be honest: the first time I read about it, I thought everything was overcomplicated.
&ldquo;Just save the state, why do you need to store every single thing that happened?&rdquo;
But before understanding what it is, I think it&rsquo;s fundamental to understand what problems it tries to solve.</p><h2 id=what-is-event-sourcing-really>What is Event Sourcing (really)?<a hidden class=anchor aria-hidden=true href=#what-is-event-sourcing-really>#</a></h2><p>Think about your bank account. When you open your banking app, you see a balance. That&rsquo;s state. But how did you get there? You had deposits, withdrawals, transfers, fees. Those are events.</p><p>Most systems only store the current balance. Done. Event Sourcing flips that: it stores every event that ever happened, and derives the current state by replaying them.
Your balance isn&rsquo;t stored directly; it&rsquo;s calculated from every transaction since you opened the account.</p><p>Why would anyone do this? Because in some domains, the events <em>are</em> the truth. The history matters. Auditing, compliance, debugging production issues, understanding user behavior, all of that becomes trivial when you have the full event log.</p><p>Of course, this sounds insane to most developers at first. &ldquo;You&rsquo;re telling me I have to replay thousands of events just to know if a user has enough credit?&rdquo; More or less. There are snapshots and optimizations for that.</p><h2 id=when-should-you-use-event-sourcing>When should you use Event Sourcing?<a hidden class=anchor aria-hidden=true href=#when-should-you-use-event-sourcing>#</a></h2><p>Let&rsquo;s be real: most CRUD apps don&rsquo;t need this. If you&rsquo;re building a basic task manager or a blog platform, just use Spring Data JPA.</p><p>Event Sourcing makes sense when audit trails are critical. Let&rsquo;s think about financial systems, healthcare, legal stuff.
Or when the process matters as much as the outcome, like order fulfillment or approval workflows.
When you need to replay or reprocess past decisions for analytics or ML training data. When business rules change and you need to reinterpret tax calculations, pricing models, and things like that.</p><p>When does it make <em>less</em> sense? Simple CRUD where the current state is all that matters. High throughput write scenarios with no historical value. Teams not ready for the mental overhead of eventual consistency. Tight deadlines with no time to learn the model.</p><p>Trade-offs? You&rsquo;re dealing with more complex queries, more moving parts, more storage. Every event is persisted forever. There&rsquo;s a learning curve you have to deal with.</p><h2 id=axon-framework-in-2-minutes>Axon Framework in 2 minutes<a hidden class=anchor aria-hidden=true href=#axon-framework-in-2-minutes>#</a></h2><p>Axon is a Java framework that makes Event Sourcing and CQRS (Command Query Responsibility Segregation) less painful. Without it, you have to build your own event store, handle command routing, manage projections, and deal with eventual consistency. It&rsquo;s a lot of stuff.</p><p>Axon gives you an event store out of the box, aggregates that manage their own consistency, automatic command and query handling, sagas for long-running business processes, and snapshot support so you don&rsquo;t replay all events every time.</p><p>It doesn&rsquo;t make Event Sourcing easy, but it makes it survivable. You still have to think differently about your domain model. You still have to deal with eventual consistency. But at least the plumbing is handled.</p><h2 id=lets-see-a-real-use-case-product-lifecycle>Let&rsquo;s see a real use case: Product lifecycle<a hidden class=anchor aria-hidden=true href=#lets-see-a-real-use-case-product-lifecycle>#</a></h2><p>Let&rsquo;s say you&rsquo;re building a system that manages product orders. A product goes through multiple stages: <em>reserved</em>, <em>confirmed</em>, <em>delivered</em>. Different teams interact with it. Support needs to know why a product got stuck. Finance needs to audit when things were confirmed and payment results.</p><p>With traditional JPA entities, you&rsquo;d probably have something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Entity</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Product</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Id</span> <span style=color:#66d9ef>val</span> id: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> status: ProductStatus,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> customerId: String?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> amount: BigDecimal?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> reservedAt: Instant?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> confirmedAt: Instant?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> deliveredAt: Instant?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> canceledAt: Instant?,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> cancelReason: String?
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>This works until it doesn&rsquo;t. You start adding more fields: <code>canceledAt</code>, <code>canceledReason</code>, <code>confirmedBy</code>, <code>reservationExpiredAt</code>. Your entity becomes a bit heavy. Queries get messy. And when someone asks &ldquo;why did this product get delivered without confirmation?&rdquo; you have no idea because you only stored the final state.</p><h2 id=solving-the-problem-with-event-sourcing>Solving the problem with Event Sourcing<a hidden class=anchor aria-hidden=true href=#solving-the-problem-with-event-sourcing>#</a></h2><p>Quick terminology crash course, because you&rsquo;ll see these everywhere:</p><p><strong>Aggregate</strong> - The single source of truth for a specific entity. It enforces business rules and decides whether a command is valid. Think of it as a goalkeeper that protects consistency.</p><p><strong>Command</strong> - An instruction to do something (&ldquo;ReserveProduct&rdquo;, &ldquo;ConfirmOrder&rdquo;). It can be rejected if it violates business rules.</p><p><strong>Event</strong> - A fact that already happened (&ldquo;ProductReserved&rdquo;, &ldquo;OrderConfirmed&rdquo;). Events can&rsquo;t be rejected because they&rsquo;re in the past.</p><p><strong>Projection</strong> - A read model built by listening to events. It&rsquo;s optimized for queries, not for business logic. You can have multiple projections for different purposes.</p><p><strong>Saga</strong> - A long-running process that coordinates multiple aggregates and represents a workflow. It listens to events and sends commands to orchestrate complex workflows (like &ldquo;when product is reserved, charge the credit card, then confirm the order&rdquo;).</p><p>With Axon, you model the lifecycle as a series of events. The aggregate replays them to reconstruct its state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Aggregate</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductAggregate</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@AggregateIdentifier</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> productId: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>var</span> state: ProductState? = <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> customerId: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> amount: BigDecimal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CommandHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constructor</span>(command: ReserveProductCommand) : <span style=color:#66d9ef>this</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (state <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> IllegalStateException(<span style=color:#e6db74>&#34;Product cannot be reserved twice.&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        apply(ProductReservedEvent(command.productId, command.customerId, command.amount))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EventSourcingHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductReservedEvent) {
</span></span><span style=display:flex><span>        productId = event.productId
</span></span><span style=display:flex><span>        customerId = event.customerId
</span></span><span style=display:flex><span>        amount = event.amount
</span></span><span style=display:flex><span>        state = <span style=color:#a6e22e>ProductState</span>.RESERVED
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@CommandHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>handle</span>(command: ConfirmProductCommand) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (state <span style=color:#f92672>!=</span> <span style=color:#a6e22e>ProductState</span>.RESERVED) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> IllegalStateException(<span style=color:#e6db74>&#34;Only a RESERVED product can be confirmed.&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        apply(ProductConfirmedEvent(productId))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EventSourcingHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductConfirmedEvent) {
</span></span><span style=display:flex><span>        state = <span style=color:#a6e22e>ProductState</span>.CONFIRMED
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductState</span> {
</span></span><span style=display:flex><span>        RESERVED, CONFIRMED, DELIVERED, CANCELED
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>See what&rsquo;s happening? Commands express intent. Events express facts. The aggregate enforces rules.</p><p>When you load a <code>ProductAggregate</code> from the event store, Axon replays events rebuilding the state. You get full traceability for free (or at least that&rsquo;s the perception).</p><p>For queries, you build projections:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductProjection</span>(<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> jdbcTemplate: JdbcTemplate) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EventHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductReservedEvent) {
</span></span><span style=display:flex><span>        jdbcTemplate.update(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;INSERT INTO product_view (product_id, status, customer_id, amount, reserved_at) VALUES (?, ?, ?, ?, ?)&#34;</span>,
</span></span><span style=display:flex><span>            event.productId, <span style=color:#e6db74>&#34;RESERVED&#34;</span>, event.customerId, event.amount, <span style=color:#a6e22e>Instant</span>.now()
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EventHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductConfirmedEvent) {
</span></span><span style=display:flex><span>        jdbcTemplate.update(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;UPDATE product_view SET status = ?, confirmed_at = ? WHERE product_id = ?&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;CONFIRMED&#34;</span>, <span style=color:#a6e22e>Instant</span>.now(), event.productId
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@QueryHandler</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>handle</span>(query: GetProductQuery): ProductView? {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> jdbcTemplate.queryForObject(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;SELECT * FROM product_view WHERE product_id = ?&#34;</span>,
</span></span><span style=display:flex><span>            { rs, _ <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                ProductView(
</span></span><span style=display:flex><span>                    productId = rs.getString(<span style=color:#e6db74>&#34;product_id&#34;</span>),
</span></span><span style=display:flex><span>                    status = rs.getString(<span style=color:#e6db74>&#34;status&#34;</span>),
</span></span><span style=display:flex><span>                    customerId = rs.getString(<span style=color:#e6db74>&#34;customer_id&#34;</span>),
</span></span><span style=display:flex><span>                    amount = rs.getBigDecimal(<span style=color:#e6db74>&#34;amount&#34;</span>),
</span></span><span style=display:flex><span>                    reservedAt = rs.getTimestamp(<span style=color:#e6db74>&#34;reserved_at&#34;</span>)<span style=color:#f92672>?.</span>toInstant(),
</span></span><span style=display:flex><span>                    confirmedAt = rs.getTimestamp(<span style=color:#e6db74>&#34;confirmed_at&#34;</span>)<span style=color:#f92672>?.</span>toInstant()
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>            query.productId
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The projection listens to events and builds a read model optimized for queries. You can have multiple projections for different use cases. One for the API. One for reporting. One for machine learning.
The read model can be persisted on a table, a NoSQL database, exported to a data warehouse, whatever fits your needs.</p><p>Now, what about sagas? Let&rsquo;s say your product reservation needs to trigger a payment, and only after payment succeeds should the product be confirmed. That&rsquo;s cross aggregate coordination.
A saga listens to <code>ProductReservedEvent</code>, sends a <code>ChargePaymentCommand</code>, waits for <code>PaymentSucceededEvent</code>, then sends <code>ConfirmProductCommand</code>. If payment fails, it sends <code>CancelReservationCommand</code>. You&rsquo;re orchestrating a multi-step process without coupling your aggregates together. It&rsquo;s messy in traditional architectures-sagas make it explicit and testable.</p><p>Here&rsquo;s what the saga looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>@Saga</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProductLifecycleSaga</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> productId: String
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>lateinit</span> <span style=color:#66d9ef>var</span> paymentId: String
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@StartSaga</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductReservedEvent, commandGateway: CommandGateway) {
</span></span><span style=display:flex><span>        productId = event.productId
</span></span><span style=display:flex><span>        paymentId = <span style=color:#a6e22e>UUID</span>.randomUUID().toString()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        commandGateway.send&lt;Any&gt;(ChargePaymentCommand(
</span></span><span style=display:flex><span>            paymentId = paymentId,
</span></span><span style=display:flex><span>            productId = event.productId,
</span></span><span style=display:flex><span>            customerId = event.customerId,
</span></span><span style=display:flex><span>            amount = event.amount
</span></span><span style=display:flex><span>        ))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: PaymentSucceededEvent, commandGateway: CommandGateway) {
</span></span><span style=display:flex><span>        commandGateway.send&lt;Any&gt;(ConfirmProductCommand(event.productId))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: PaymentFailedEvent, commandGateway: CommandGateway) {
</span></span><span style=display:flex><span>        commandGateway.send&lt;Any&gt;(CancelReservationCommand(
</span></span><span style=display:flex><span>            productId = event.productId,
</span></span><span style=display:flex><span>            reason = <span style=color:#e6db74>&#34;Payment failed: </span><span style=color:#e6db74>${event.reason}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        ))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductConfirmedEvent, commandGateway: CommandGateway) {
</span></span><span style=display:flex><span>        commandGateway.send&lt;Any&gt;(DeliverProductCommand(productId))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EndSaga</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductDeliveredEvent) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@EndSaga</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SagaEventHandler</span>(associationProperty = <span style=color:#e6db74>&#34;productId&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>on</span>(event: ProductReservationCanceledEvent) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The saga starts when a product is reserved, sends a payment charge command, waits for payment success or failure, then either confirms the product (on success) or cancels the reservation (on failure). After confirmation, it triggers delivery. Each step is explicit. Each transition is traceable. If something fails, you know exactly where and why.</p><p>And here&rsquo;s the upside: if business rules change, you can rebuild projections from scratch by replaying all events. Try doing that with a relational database where you&rsquo;ve been mutating rows for three years.</p><p>Event Sourcing isn&rsquo;t a magic bullet. It won&rsquo;t make your codebase simpler. It won&rsquo;t make your queries faster. But it will make certain problems like auditing, compliance and complex workflows much more manageable.</p><p>Axon Framework handles the boring infrastructure stuff so you can focus on modeling your domain properly. It&rsquo;s opinionated, which is good when you&rsquo;re trying to learn a new paradigm.</p><p>Is it overkill for most projects? Absolutely. Should you use it everywhere? Absolutely no. But when you&rsquo;re staring at a tangled mess of status fields and audit data, and someone asks &ldquo;how did we get here?&rdquo; that&rsquo;s when Event Sourcing starts to make sense.</p><p>I&rsquo;m still learning this stuff, honestly. Some days I love it. Some days I miss the simplicity of <code>UPDATE products SET status = 'CONFIRMED'</code>. But for the right problems, it&rsquo;s an efficient way to model the domain.</p><p><em>One thing I haven&rsquo;t covered here</em>: the whole &ldquo;separate your reads from your writes&rdquo; thing. That&rsquo;s CQRS, and it deserves its own conversation. Spoiler: it works really well with Event Sourcing, but you don&rsquo;t need one to use the other.</p><hr><h2 id=want-to-go-deeper>Want to go deeper?<a hidden class=anchor aria-hidden=true href=#want-to-go-deeper>#</a></h2><p>If you&rsquo;re curious and want to learn more about this stuff, here are some resources that actually helped me:</p><p><strong>Axon Framework Documentation</strong><br><a href=https://docs.axoniq.io/>https://docs.axoniq.io/</a><br>The official docs (surprisingly readable).</p><p><strong>Building Event-Driven Microservices</strong><br>by Adam Bellemare (O&rsquo;Reilly Media)<br>This book isn&rsquo;t specifically about Axon, but it&rsquo;s one of the better explanations of event-driven architecture I&rsquo;ve read. It covers event sourcing, stream processing, and how to actually structure these systems in production. Less theory, more &ldquo;here&rsquo;s how you actually build this.&rdquo;</p><p><strong>Domain-Driven Design</strong><br>by Eric Evans (Addison-Wesley)<br>The blue book. If you&rsquo;re going to do Event Sourcing seriously, you need to understand DDD.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://vsantona.github.io/>Vincenzo Santonastaso</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>